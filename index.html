<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markov Chain Stationary Distribution Calculator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            font-size: 14px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .header {
            background: #ffffff;
            border-bottom: 2px solid #e9ecef;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #212529;
        }

        .header p {
            font-size: 16px;
            color: #6c757d;
            font-weight: 400;
        }

        .content {
            padding: 30px;
        }

        .input-section {
            margin-bottom: 40px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background: #ffffff;
        }

        .section-header {
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            padding: 16px 20px;
            font-weight: 600;
            font-size: 16px;
            color: #495057;
        }

        .section-content {
            padding: 20px;
        }

        .matrix-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            font-weight: 500;
            color: #495057;
        }

        .control-group select {
            padding: 6px 12px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 14px;
            background: white;
        }

        .matrix-input {
            display: grid;
            gap: 8px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .matrix-row {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .matrix-input input {
            width: 70px;
            height: 40px;
            text-align: center;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
        }

        .matrix-input input:focus {
            border-color: #495057;
            outline: none;
            box-shadow: 0 0 0 2px rgba(73, 80, 87, 0.1);
        }

        .button-group {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            background: white;
            color: #495057;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        .btn-primary {
            background: #495057;
            color: white;
            border-color: #495057;
        }

        .btn-primary:hover {
            background: #343a40;
            border-color: #343a40;
        }

        .results-section {
            margin-top: 30px;
            display: none;
        }

        .method-container {
            background: white;
            border: 1px solid #dee2e6;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .method-header {
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            padding: 16px 20px;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #495057;
        }

        .method-header:hover {
            background: #e9ecef;
        }

        .method-header::after {
            content: '+';
            font-size: 18px;
            font-weight: bold;
        }

        .method-header.active::after {
            content: '−';
        }

        .method-content {
            padding: 20px;
            display: none;
        }

        .method-content.active {
            display: block;
        }

        .step {
            margin-bottom: 24px;
            border-left: 3px solid #dee2e6;
            padding-left: 16px;
        }

        .step-title {
            font-weight: 600;
            color: #343a40;
            margin-bottom: 8px;
            font-size: 15px;
        }

        .step-content {
            color: #495057;
            line-height: 1.5;
        }

        .matrix-display {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            padding: 12px;
            margin: 12px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            overflow-x: auto;
            white-space: pre;
        }

        .vector-display {
            background: #f1f3f4;
            border: 1px solid #ced4da;
            border-radius: 3px;
            padding: 12px;
            margin: 12px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            font-weight: 500;
        }

        .gauss-step {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            padding: 16px;
            margin: 12px 0;
            border-radius: 3px;
        }

        .gauss-step-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
            font-size: 14px;
        }

        .augmented-matrix {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: white;
            padding: 12px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            margin: 8px 0;
            overflow-x: auto;
        }

        .matrix-operation {
            color: #6c757d;
            font-style: italic;
            margin: 4px 0;
            font-size: 13px;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 12px;
            border-radius: 3px;
            margin: 12px 0;
            font-size: 13px;
        }

        .final-result {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 20px;
            border-radius: 4px;
            margin-top: 30px;
        }

        .final-result h3 {
            margin-bottom: 12px;
            font-size: 18px;
            font-weight: 600;
        }

        .result-item {
            margin: 6px 0;
            font-size: 14px;
            font-family: 'Courier New', monospace;
        }

        .validation-error {
            color: #dc3545;
            font-size: 13px;
            margin-top: 8px;
        }

        .validation-success {
            color: #28a745;
            font-size: 13px;
            margin-top: 8px;
        }

        table {
            border-collapse: collapse;
            margin: 8px 0;
        }

        table td, table th {
            padding: 4px 8px;
            text-align: center;
            border: 1px solid #dee2e6;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        table th {
            background: #f8f9fa;
            font-weight: 600;
        }

        .iteration-table {
            max-height: 300px;
            overflow-y: auto;
            margin: 12px 0;
        }

        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }
            
            .matrix-controls {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Markov Chain Stationary Distribution Calculator</h1>
            <p>Calculate the stationary distribution with detailed step-by-step solutions</p>
        </div>

        <div class="content">
            <div class="input-section">
                <div class="section-header">Transition Matrix Input</div>
                <div class="section-content">
                    <div class="matrix-controls">
                        <div class="control-group">
                            <label for="matrixSize">Matrix size:</label>
                            <select id="matrixSize" onchange="updateMatrixSize()">
                                <option value="2">2×2</option>
                                <option value="3" selected>3×3</option>
                                <option value="4">4×4</option>
                                <option value="5">5×5</option>
                            </select>
                        </div>
                    </div>

                    <div id="matrixContainer" class="matrix-input"></div>

                    <div class="button-group">
                        <button class="btn" onclick="loadExampleMatrix()">Load Example</button>
                        <button class="btn" onclick="generateRandomMatrix()">Generate Random</button>
                        <button class="btn btn-primary" onclick="calculateStationary()">Calculate Distribution</button>
                    </div>

                    <div id="validationMessage"></div>
                </div>
            </div>

            <div id="results" class="results-section">
                <div id="method1" class="method-container">
                    <div class="method-header" onclick="toggleMethod('method1')">
                        Method 1: Power Iteration (Eigenvalue approach)
                    </div>
                    <div class="method-content" id="method1-content"></div>
                </div>

                <div id="method2" class="method-container">
                    <div class="method-header" onclick="toggleMethod('method2')">
                        Method 2: Linear System with Gaussian Elimination
                    </div>
                    <div class="method-content" id="method2-content"></div>
                </div>

                <div id="method3" class="method-container">
                    <div class="method-header" onclick="toggleMethod('method3')">
                        Method 3: Matrix Powers Convergence
                    </div>
                    <div class="method-content" id="method3-content"></div>
                </div>

                <div id="finalResult" class="final-result"></div>
            </div>
        </div>
    </div>

    <script>

        let matrixSize = 3;
        let currentResult = null;

        function updateMatrixSize() {
            matrixSize = parseInt(document.getElementById('matrixSize').value);
            createMatrixInput();
        }

        function createMatrixInput() {
            const container = document.getElementById('matrixContainer');
            container.innerHTML = '';
            
            for (let i = 0; i < matrixSize; i++) {
                const row = document.createElement('div');
                row.className = 'matrix-row';
                
                for (let j = 0; j < matrixSize; j++) {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.step = '0.01';
                    input.min = '0';
                    input.max = '1';
                    input.id = `matrix_${i}_${j}`;
                    input.value = '0';
                    input.oninput = validateInput;
                    row.appendChild(input);
                }
                container.appendChild(row);
            }
        }

        function validateInput(event) {
            const value = parseFloat(event.target.value);
            if (value < 0) event.target.value = '0';
            if (value > 1) event.target.value = '1';
        }

        function loadExampleMatrix() {
            const examples = {
                2: [[0.7, 0.3], [0.4, 0.6]],
                3: [[0.6, 0.2, 0.2], [0.4, 0.6, 0.0], [0.0, 1.0, 0.0]],
                4: [[0.5, 0.3, 0.2, 0.0], [0.1, 0.4, 0.3, 0.2], [0.0, 0.2, 0.6, 0.2], [0.0, 0.0, 0.4, 0.6]]
            };
            
            const example = examples[matrixSize];
            for (let i = 0; i < matrixSize; i++) {
                for (let j = 0; j < matrixSize; j++) {
                    document.getElementById(`matrix_${i}_${j}`).value = example[i][j];
                }
            }
        }

        function generateRandomMatrix() {
            for (let i = 0; i < matrixSize; i++) {
                let sum = 0;
                const values = [];
                
                // Generate random values
                for (let j = 0; j < matrixSize - 1; j++) {
                    const val = Math.random() * (1 - sum);
                    values.push(val);
                    sum += val;
                }
                values.push(1 - sum); // Last value to make sum = 1
                
                // Shuffle the values
                for (let j = values.length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [values[j], values[k]] = [values[k], values[j]];
                }
                
                // Set values
                for (let j = 0; j < matrixSize; j++) {
                    document.getElementById(`matrix_${i}_${j}`).value = values[j].toFixed(3);
                }
            }
        }

        function getMatrixFromInputs() {
            const matrix = [];
            for (let i = 0; i < matrixSize; i++) {
                const row = [];
                for (let j = 0; j < matrixSize; j++) {
                    const value = parseFloat(document.getElementById(`matrix_${i}_${j}`).value) || 0;
                    row.push(value);
                }
                matrix.push(row);
            }
            return matrix;
        }

        function validateMatrix(matrix) {
            const tolerance = 1e-6;
            for (let i = 0; i < matrix.length; i++) {
                const rowSum = matrix[i].reduce((sum, val) => sum + val, 0);
                if (Math.abs(rowSum - 1) > tolerance) {
                    return false;
                }
            }
            return true;
        }

        function formatMatrix(matrix) {
            let result = '[';
            for (let i = 0; i < matrix.length; i++) {
                result += '[' + matrix[i].map(val => val.toFixed(4)).join(', ') + ']';
                if (i < matrix.length - 1) result += ',\n ';
            }
            result += ']';
            return result;
        }

        function formatVector(vector) {
            return '[' + vector.map(val => val.toFixed(6)).join(', ') + ']';
        }

        // Matrix operations
        function transpose(matrix) {
            const result = [];
            for (let i = 0; i < matrix[0].length; i++) {
                const row = [];
                for (let j = 0; j < matrix.length; j++) {
                    row.push(matrix[j][i]);
                }
                result.push(row);
            }
            return result;
        }

        function multiply(A, B) {
            const result = [];
            for (let i = 0; i < A.length; i++) {
                const row = [];
                for (let j = 0; j < B[0].length; j++) {
                    let sum = 0;
                    for (let k = 0; k < A[0].length; k++) {
                        sum += A[i][k] * B[k][j];
                    }
                    row.push(sum);
                }
                result.push(row);
            }
            return result;
        }

        function matrixPower(matrix, power) {
            let result = matrix.map(row => [...row]);
            for (let p = 1; p < power; p++) {
                result = multiply(result, matrix);
            }
            return result;
        }

        function identity(n) {
            const result = [];
            for (let i = 0; i < n; i++) {
                const row = [];
                for (let j = 0; j < n; j++) {
                    row.push(i === j ? 1 : 0);
                }
                result.push(row);
            }
            return result;
        }

        function subtract(A, B) {
            const result = [];
            for (let i = 0; i < A.length; i++) {
                const row = [];
                for (let j = 0; j < A[0].length; j++) {
                    row.push(A[i][j] - B[i][j]);
                }
                result.push(row);
            }
            return result;
        }

        function solveLinearSystem(A, b) {
            const n = A.length;
            const augmented = [];
            
            // Create augmented matrix
            for (let i = 0; i < n; i++) {
                augmented.push([...A[i], b[i]]);
            }
            
            // Gaussian elimination
            for (let i = 0; i < n; i++) {
                // Find pivot
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                        maxRow = k;
                    }
                }
                [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
                
                // Make diagonal 1
                const pivot = augmented[i][i];
                for (let j = i; j <= n; j++) {
                    augmented[i][j] /= pivot;
                }
                
                // Eliminate column
                for (let k = 0; k < n; k++) {
                    if (k !== i) {
                        const factor = augmented[k][i];
                        for (let j = i; j <= n; j++) {
                            augmented[k][j] -= factor * augmented[i][j];
                        }
                    }
                }
            }
            
            // Extract solution
            const solution = [];
            for (let i = 0; i < n; i++) {
                solution.push(augmented[i][n]);
            }
            return solution;
        }

        function calculateStationary() {
            const matrix = getMatrixFromInputs();
            
            if (!validateMatrix(matrix)) {
                alert('⚠️ Errore: Ogni riga della matrice deve sommare a 1 (matrice stocastica)');
                return;
            }

            // Show results section
            document.getElementById('results').style.display = 'block';
            
            // Method 1: Power iteration (simplified eigenvalue approach)
            calculateMethod1(matrix);
            
            // Method 2: Linear system
            calculateMethod2(matrix);
            
            // Method 3: Matrix powers
            calculateMethod3(matrix);
            
            // Show final result
            showFinalResult();
            
            // Auto-expand first method
            toggleMethod('method1');
        }

        function calculateMethod1(matrix) {
            const content = document.getElementById('method1-content');
            let html = '';
            
            html += `<div class="step">
                <div class="step-title">Passo 1: Trasposizione della matrice</div>
                <div class="step-content">
                    Per trovare π tale che π = πP, risolviamo πP^T = π<br>
                    Matrice originale P:
                    <div class="matrix-display">${formatMatrix(matrix)}</div>
                    Matrice trasposta P^T:
                    <div class="matrix-display">${formatMatrix(transpose(matrix))}</div>
                </div>
            </div>`;
            
            // Simplified power iteration
            html += `<div class="step">
                <div class="step-title">Passo 2: Iterazione delle potenze</div>
                <div class="step-content">
                    Partiamo con un vettore iniziale e iteriamo π_{k+1} = π_k × P<br>
                    Vettore iniziale: [${(1/matrixSize).toFixed(6)}${''.repeat(matrixSize-1).split('').map(() => `, ${(1/matrixSize).toFixed(6)}`).join('')}]
                </div>
            </div>`;
            
            // Power iteration
            let pi = new Array(matrixSize).fill(1/matrixSize);
            const iterations = [pi.slice()];
            
            for (let iter = 0; iter < 20; iter++) {
                const newPi = new Array(matrixSize).fill(0);
                for (let i = 0; i < matrixSize; i++) {
                    for (let j = 0; j < matrixSize; j++) {
                        newPi[i] += pi[j] * matrix[j][i];
                    }
                }
                pi = newPi;
                if (iter < 5 || iter === 19) {
                    iterations.push(pi.slice());
                }
            }
            
            for (let i = 0; i < Math.min(5, iterations.length); i++) {
                html += `<div class="step">
                    <div class="step-title">Iterazione ${i}</div>
                    <div class="step-content">
                        π${i} = ${formatVector(iterations[i])}
                    </div>
                </div>`;
            }
            
            if (iterations.length > 5) {
                html += `<div class="step">
                    <div class="step-title">... (altre iterazioni) ...</div>
                    <div class="step-content">
                        Risultato finale dopo 20 iterazioni:
                        <div class="vector-display">π = ${formatVector(pi)}</div>
                    </div>
                </div>`;
            }
            
            html += `<div class="step">
                <div class="step-title">Verifica</div>
                <div class="step-content">
                    Controlliamo che π × P = π:<br>
                    ${formatVector(multiplyVectorMatrix(pi, matrix))} ≈ ${formatVector(pi)}<br>
                    Somma componenti: ${pi.reduce((sum, val) => sum + val, 0).toFixed(6)}
                </div>
            </div>`;
            
            content.innerHTML = html;
            currentResult = pi;
        }

        function calculateMethod2(matrix) {
            const content = document.getElementById('method2-content');
            let html = '';
            
            const PT = transpose(matrix);
            const I = identity(matrixSize);
            const A = subtract(I, PT);
            
            html += `<div class="step">
                <div class="step-title">Passo 1: Costruzione del sistema</div>
                <div class="step-content">
                    Vogliamo risolvere (I - P^T)π = 0 con il vincolo Σπᵢ = 1<br><br>
                    Matrice identità I:
                    <div class="matrix-display">${formatMatrix(I)}</div>
                    I - P^T:
                    <div class="matrix-display">${formatMatrix(A)}</div>
                </div>
            </div>`;
            
            // Replace last equation with normalization
            A[matrixSize-1] = new Array(matrixSize).fill(1);
            const b = new Array(matrixSize).fill(0);
            b[matrixSize-1] = 1;
            
            html += `<div class="step">
                <div class="step-title">Passo 2: Aggiunta vincolo di normalizzazione</div>
                <div class="step-content">
                    Sostituiamo l'ultima equazione con Σπᵢ = 1:<br>
                    Sistema finale:
                    <div class="matrix-display">${formatMatrix(A)}</div>
                    Termine noto: ${formatVector(b)}
                </div>
            </div>`;
            
            const solution = solveLinearSystem(A, b);
            
            html += `<div class="step">
                <div class="step-title">Passo 3: Soluzione del sistema lineare</div>
                <div class="step-content">
                    Risolviamo il sistema usando eliminazione Gaussiana:<br>
                    <div class="vector-display">π = ${formatVector(solution)}</div>
                </div>
            </div>`;
            
            html += `<div class="step">
                <div class="step-title">Verifica</div>
                <div class="step-content">
                    Controlliamo che π × P = π:<br>
                    ${formatVector(multiplyVectorMatrix(solution, matrix))} ≈ ${formatVector(solution)}<br>
                    Somma componenti: ${solution.reduce((sum, val) => sum + val, 0).toFixed(6)}
                </div>
            </div>`;
            
            content.innerHTML = html;
        }

        function calculateMethod3(matrix) {
            const content = document.getElementById('method3-content');
            let html = '';
            
            html += `<div class="step">
                <div class="step-title">Passo 1: Calcolo delle potenze della matrice</div>
                <div class="step-content">
                    Quando n → ∞, P^n converge a una matrice dove ogni riga è la distribuzione stazionaria<br><br>
                    Matrice originale P:
                    <div class="matrix-display">${formatMatrix(matrix)}</div>
                </div>
            </div>`;
            
            const powers = [2, 5, 10, 20, 50];
            let finalMatrix = matrix;
            
            for (const power of powers) {
                const powered = matrixPower(matrix, power);
                html += `<div class="step">
                    <div class="step-title">P^${power}</div>
                    <div class="step-content">
                        <div class="matrix-display">${formatMatrix(powered)}</div>
                    </div>
                </div>`;
                
                if (power === 50) {
                    finalMatrix = powered;
                }
            }
            
            const stationaryFromPower = finalMatrix[0];
            
            html += `<div class="step">
                <div class="step-title">Distribuzione stazionaria</div>
                <div class="step-content">
                    Prendiamo la prima riga di P^50 come distribuzione stazionaria:<br>
                    <div class="vector-display">π = ${formatVector(stationaryFromPower)}</div>
                </div>
            </div>`;
            
            html += `<div class="step">
                <div class="step-title">Verifica</div>
                <div class="step-content">
                    Controlliamo che π × P = π:<br>
                    ${formatVector(multiplyVectorMatrix(stationaryFromPower, matrix))} ≈ ${formatVector(stationaryFromPower)}<br>
                    Somma componenti: ${stationaryFromPower.reduce((sum, val) => sum + val, 0).toFixed(6)}
                </div>
            </div>`;
            
            content.innerHTML = html;
        }

        function multiplyVectorMatrix(vector, matrix) {
            const result = new Array(matrix[0].length).fill(0);
            for (let j = 0; j < matrix[0].length; j++) {
                for (let i = 0; i < vector.length; i++) {
                    result[j] += vector[i] * matrix[i][j];
                }
            }
            return result;
        }

        function showFinalResult() {
            const finalDiv = document.getElementById('finalResult');
            if (!currentResult) return;
            
            let html = `<h3>🎯 Distribuzione Stazionaria Finale</h3>`;
            
            for (let i = 0; i < currentResult.length; i++) {
                html += `<div class="result-item">Stato ${i+1}: π${i+1} = ${currentResult[i].toFixed(6)} (${(currentResult[i] * 100).toFixed(2)}%)</div>`;
            }
            
            html += `<div style="margin-top: 20px; font-size: 0.9rem; opacity: 0.8;">
                La distribuzione stazionaria rappresenta le probabilità a lungo termine di trovarsi in ciascuno stato
            </div>`;
            
            finalDiv.innerHTML = html;
        }

        function toggleMethod(methodId) {
            const content = document.getElementById(methodId + '-content');
            const allContents = document.querySelectorAll('.method-content');
            
            // Close all other methods
            allContents.forEach(c => {
                if (c.id !== methodId + '-content') {
                    c.classList.remove('active');
                }
            });
            
            // Toggle current method
            content.classList.toggle('active');
        }

        // Initialize
        createMatrixInput();
        loadExampleMatrix();
    </script>
</body>
</html>